1. 문제 이해하기

(문제 만들기 좋음)

객체지향 설계 원칙(SOLID)
단일 책임 원칙 (Single responsibility principle) S
개방-폐쇄 원칙 (Open/closed principle) O
리스코프 치환 원칙 (Liskov substitution principle) L
인터페이스 분리 원칙 (Interface segregation principle) I
의존관계 역전 원칙 (Dependency inversion principle) D


1.1 단일 책임 원칙(SRP)

“하나의 클래스(또는 모듈)는 오직 하나의 책임만 가져야 한다.”
여기서 책임이란 단순히 “하나의 기능”이 아니라,
**변경의 이유(Reason to change)**를 의미해요.

SRP(단일 책임 원칙)는 너무 과하게 지켜도, 너무 느슨하게 지켜도 문제가 생기기 때문에 ‘적절한 균형’이 핵심

SRP(단일 책임 원칙)는 클래스나 함수뿐 아니라 “폴더 구조”, “모듈 분리”, “도메인 분류 작업”에도 그대로 확장해서 생각할 수 있는 원칙이에요.
즉, “무엇을 기준으로 나누어야 하는가?”라는 질문 자체가 SRP의 핵심과 맞닿아 있어요.

오히려 “변경의 이유(Reason to change)”는 좋은 커밋 메시지의 핵심 기준이라고 해도 과언이 아니에요.
SRP의 철학이 “하나의 변경 이유만 가지게 하라”라면, 좋은 커밋도 **“하나의 변경 이유만 담아라”**에 가까워요.

Conventional Commits는 가장 널리 쓰이고, 자동화·릴리즈 관리·CI/CD와도 잘 맞기 때문에 팀 규칙으로 채택하기 좋습니다.

1.2 개방-폐쇄 원칙(OCP)

Q OCP란?

“소프트웨어 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.”

- OCP를 실제 프로젝트 구조에 적용하는 방법
- OCP와 SRP의 관계
- 디자인 패턴과의 연결

Q 변경 가능성을 구분하는 방법

변경 가능성이 높은 부분과 낮은 부분을 구별하는 건 **OCP(Open/Closed Principle)**를 실제로 적용할 때 가장 중요한 감각이에요.
이건 단순히 “추상화할까 말까”의 문제가 아니라, 어디가 자주 바뀌고 어디가 안정적인지 판단하는 능력이죠.

인터페이스 기반 구조는 **OCP(개방-폐쇄 원칙)**를 실제 코드와 프로젝트 구조에 자연스럽게 녹여내는 가장 강력한 방법이에요.
쉽게 말하면,
“변경될 수 있는 부분은 인터페이스로 추상화하고, 실제 구현은 외부로 분리하는 구조”

Q. 인터페이스와 템플릿의 차이점

인터페이스는 “무엇을 할 수 있는가”를 정의하고,
템플릿은 “어떻게 할 것인가의 흐름”을 정의한다.

Q 라이브러리는 인터페이스인가 템플릿인가?

라이브러리는 인터페이스일 수도 있고 템플릿일 수도 있고, 둘 다 아닐 수도 있다.
라이브러리는 개념이 아니라 “도구”이고, 그 안에 어떤 구조를 제공하느냐가 인터페이스 기반인지 템플릿 기반인지 결정한다.

Q 라이브러리에 의존한 개발은 어떤 원칙을 위배하는가?

라이브러리에 직접 의존하는 개발은 DIP(의존성 역전 원칙)를 위배할 가능성이 높고,
그 결과 OCP(개방-폐쇄 원칙)도 함께 위배될 수 있다.

Q GPT에 의존한 개발은 어떤 원칙을 위배하는가?

GPT에 직접 의존한 개발은 DIP(의존성 역전 원칙)를 위배하고,
그 결과 OCP(개방-폐쇄 원칙)도 함께 위배될 가능성이 높다.

Q SOLID중 완벽하게 원칙을 지켜야지만 프로그램을 사용할 수 있는가?

아주 좋은 질문이에요. 많은 개발자들이 처음 SOLID를 배우면 “이걸 완벽하게 지켜야 좋은 코드인가?”라는 부담을 느끼는데, 결론부터 말하면 절대 그렇지 않아요.
한 줄로 정리하면
SOLID는 완벽하게 지켜야만 프로그램이 동작하는 규칙이 아니라,
더 좋은 설계를 위한 방향성이다.
필요할 때, 필요한 만큼 적용하는 것이 가장 현명하다.

Q OLID 원칙을 적용하여 이점을 가지는 것들을 수치화 할 수 있는가?

대규모 기업들은 SOLID 준수 여부를 아래 지표로 간접 측정해요:
Maintainability Index 유지보수성 점수
Cyclomatic Complexity 복잡도
Coupling Between Objects (CBO) 결합도
Lack of Cohesion of Methods (LCOM) 응집도
Depth of Inheritance Tree (DIT) 상속 깊이
Code Churn 변경량  
Defect Density 버그 밀도



2. C언어, 파이썬, 자바로 문제가 나옴
